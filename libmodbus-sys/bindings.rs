/* automatically generated by rust-bindgen */

pub const _SYS_PARAM_H : :: std :: os :: raw :: c_uint = 1 ; pub const _SYS_TYPES_H : :: std :: os :: raw :: c_uint = 1 ; pub const _FEATURES_H : :: std :: os :: raw :: c_uint = 1 ; pub const _DEFAULT_SOURCE : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ISOC11 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ISOC99 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ISOC95 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_POSIX_IMPLICITLY : :: std :: os :: raw :: c_uint = 1 ; pub const _POSIX_SOURCE : :: std :: os :: raw :: c_uint = 1 ; pub const _POSIX_C_SOURCE : :: std :: os :: raw :: c_uint = 200809 ; pub const __USE_POSIX : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_POSIX2 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_POSIX199309 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_POSIX199506 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_XOPEN2K : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_XOPEN2K8 : :: std :: os :: raw :: c_uint = 1 ; pub const _ATFILE_SOURCE : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_MISC : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ATFILE : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_FORTIFY_LEVEL : :: std :: os :: raw :: c_uint = 0 ; pub const __GLIBC_USE_DEPRECATED_GETS : :: std :: os :: raw :: c_uint = 0 ; pub const _STDC_PREDEF_H : :: std :: os :: raw :: c_uint = 1 ; pub const __STDC_IEC_559__ : :: std :: os :: raw :: c_uint = 1 ; pub const __STDC_IEC_559_COMPLEX__ : :: std :: os :: raw :: c_uint = 1 ; pub const __STDC_ISO_10646__ : :: std :: os :: raw :: c_uint = 201706 ; pub const __STDC_NO_THREADS__ : :: std :: os :: raw :: c_uint = 1 ; pub const __GNU_LIBRARY__ : :: std :: os :: raw :: c_uint = 6 ; pub const __GLIBC__ : :: std :: os :: raw :: c_uint = 2 ; pub const __GLIBC_MINOR__ : :: std :: os :: raw :: c_uint = 26 ; pub const _SYS_CDEFS_H : :: std :: os :: raw :: c_uint = 1 ; pub const __glibc_c99_flexarr_available : :: std :: os :: raw :: c_uint = 1 ; pub const __WORDSIZE : :: std :: os :: raw :: c_uint = 64 ; pub const __WORDSIZE_TIME64_COMPAT32 : :: std :: os :: raw :: c_uint = 1 ; pub const __SYSCALL_WORDSIZE : :: std :: os :: raw :: c_uint = 64 ; pub const __HAVE_GENERIC_SELECTION : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_TYPES_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_TYPESIZES_H : :: std :: os :: raw :: c_uint = 1 ; pub const __OFF_T_MATCHES_OFF64_T : :: std :: os :: raw :: c_uint = 1 ; pub const __INO_T_MATCHES_INO64_T : :: std :: os :: raw :: c_uint = 1 ; pub const __RLIM_T_MATCHES_RLIM64_T : :: std :: os :: raw :: c_uint = 1 ; pub const __FD_SETSIZE : :: std :: os :: raw :: c_uint = 1024 ; pub const __clock_t_defined : :: std :: os :: raw :: c_uint = 1 ; pub const __clockid_t_defined : :: std :: os :: raw :: c_uint = 1 ; pub const __time_t_defined : :: std :: os :: raw :: c_uint = 1 ; pub const __timer_t_defined : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_STDINT_INTN_H : :: std :: os :: raw :: c_uint = 1 ; pub const __BIT_TYPES_DEFINED__ : :: std :: os :: raw :: c_uint = 1 ; pub const _ENDIAN_H : :: std :: os :: raw :: c_uint = 1 ; pub const __LITTLE_ENDIAN : :: std :: os :: raw :: c_uint = 1234 ; pub const __BIG_ENDIAN : :: std :: os :: raw :: c_uint = 4321 ; pub const __PDP_ENDIAN : :: std :: os :: raw :: c_uint = 3412 ; pub const __BYTE_ORDER : :: std :: os :: raw :: c_uint = 1234 ; pub const __FLOAT_WORD_ORDER : :: std :: os :: raw :: c_uint = 1234 ; pub const LITTLE_ENDIAN : :: std :: os :: raw :: c_uint = 1234 ; pub const BIG_ENDIAN : :: std :: os :: raw :: c_uint = 4321 ; pub const PDP_ENDIAN : :: std :: os :: raw :: c_uint = 3412 ; pub const BYTE_ORDER : :: std :: os :: raw :: c_uint = 1234 ; pub const _BITS_BYTESWAP_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_UINTN_IDENTITY_H : :: std :: os :: raw :: c_uint = 1 ; pub const _SYS_SELECT_H : :: std :: os :: raw :: c_uint = 1 ; pub const __FD_ZERO_STOS : & 'static [ u8 ; 6usize ] = b"stosq\0" ; pub const __sigset_t_defined : :: std :: os :: raw :: c_uint = 1 ; pub const __timeval_defined : :: std :: os :: raw :: c_uint = 1 ; pub const __timespec_defined : :: std :: os :: raw :: c_uint = 1 ; pub const FD_SETSIZE : :: std :: os :: raw :: c_uint = 1024 ; pub const _SYS_SYSMACROS_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_SYSMACROS_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_PTHREADTYPES_COMMON_H : :: std :: os :: raw :: c_uint = 1 ; pub const _THREAD_SHARED_TYPES_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_PTHREADTYPES_ARCH_H : :: std :: os :: raw :: c_uint = 1 ; pub const __SIZEOF_PTHREAD_MUTEX_T : :: std :: os :: raw :: c_uint = 40 ; pub const __SIZEOF_PTHREAD_ATTR_T : :: std :: os :: raw :: c_uint = 56 ; pub const __SIZEOF_PTHREAD_RWLOCK_T : :: std :: os :: raw :: c_uint = 56 ; pub const __SIZEOF_PTHREAD_BARRIER_T : :: std :: os :: raw :: c_uint = 32 ; pub const __SIZEOF_PTHREAD_MUTEXATTR_T : :: std :: os :: raw :: c_uint = 4 ; pub const __SIZEOF_PTHREAD_COND_T : :: std :: os :: raw :: c_uint = 48 ; pub const __SIZEOF_PTHREAD_CONDATTR_T : :: std :: os :: raw :: c_uint = 4 ; pub const __SIZEOF_PTHREAD_RWLOCKATTR_T : :: std :: os :: raw :: c_uint = 8 ; pub const __SIZEOF_PTHREAD_BARRIERATTR_T : :: std :: os :: raw :: c_uint = 4 ; pub const __PTHREAD_MUTEX_LOCK_ELISION : :: std :: os :: raw :: c_uint = 1 ; pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND : :: std :: os :: raw :: c_uint = 0 ; pub const __PTHREAD_MUTEX_USE_UNION : :: std :: os :: raw :: c_uint = 0 ; pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED : :: std :: os :: raw :: c_uint = 1 ; pub const __PTHREAD_MUTEX_HAVE_PREV : :: std :: os :: raw :: c_uint = 1 ; pub const __have_pthread_attr_t : :: std :: os :: raw :: c_uint = 1 ; pub const _LIBC_LIMITS_H_ : :: std :: os :: raw :: c_uint = 1 ; pub const __GLIBC_USE_LIB_EXT2 : :: std :: os :: raw :: c_uint = 0 ; pub const __GLIBC_USE_IEC_60559_BFP_EXT : :: std :: os :: raw :: c_uint = 0 ; pub const __GLIBC_USE_IEC_60559_FUNCS_EXT : :: std :: os :: raw :: c_uint = 0 ; pub const __GLIBC_USE_IEC_60559_TYPES_EXT : :: std :: os :: raw :: c_uint = 0 ; pub const MB_LEN_MAX : :: std :: os :: raw :: c_uint = 16 ; pub const _BITS_POSIX1_LIM_H : :: std :: os :: raw :: c_uint = 1 ; pub const _POSIX_AIO_LISTIO_MAX : :: std :: os :: raw :: c_uint = 2 ; pub const _POSIX_AIO_MAX : :: std :: os :: raw :: c_uint = 1 ; pub const _POSIX_ARG_MAX : :: std :: os :: raw :: c_uint = 4096 ; pub const _POSIX_CHILD_MAX : :: std :: os :: raw :: c_uint = 25 ; pub const _POSIX_DELAYTIMER_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX_HOST_NAME_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX_LINK_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_LOGIN_NAME_MAX : :: std :: os :: raw :: c_uint = 9 ; pub const _POSIX_MAX_CANON : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX_MAX_INPUT : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX_MQ_OPEN_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_MQ_PRIO_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX_NAME_MAX : :: std :: os :: raw :: c_uint = 14 ; pub const _POSIX_NGROUPS_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_OPEN_MAX : :: std :: os :: raw :: c_uint = 20 ; pub const _POSIX_PATH_MAX : :: std :: os :: raw :: c_uint = 256 ; pub const _POSIX_PIPE_BUF : :: std :: os :: raw :: c_uint = 512 ; pub const _POSIX_RE_DUP_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX_RTSIG_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_SEM_NSEMS_MAX : :: std :: os :: raw :: c_uint = 256 ; pub const _POSIX_SEM_VALUE_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const _POSIX_SIGQUEUE_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX_SSIZE_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const _POSIX_STREAM_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_SYMLINK_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX_SYMLOOP_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_TIMER_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX_TTY_NAME_MAX : :: std :: os :: raw :: c_uint = 9 ; pub const _POSIX_TZNAME_MAX : :: std :: os :: raw :: c_uint = 6 ; pub const _POSIX_CLOCKRES_MIN : :: std :: os :: raw :: c_uint = 20000000 ; pub const NR_OPEN : :: std :: os :: raw :: c_uint = 1024 ; pub const NGROUPS_MAX : :: std :: os :: raw :: c_uint = 65536 ; pub const ARG_MAX : :: std :: os :: raw :: c_uint = 131072 ; pub const LINK_MAX : :: std :: os :: raw :: c_uint = 127 ; pub const MAX_CANON : :: std :: os :: raw :: c_uint = 255 ; pub const MAX_INPUT : :: std :: os :: raw :: c_uint = 255 ; pub const NAME_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const PATH_MAX : :: std :: os :: raw :: c_uint = 4096 ; pub const PIPE_BUF : :: std :: os :: raw :: c_uint = 4096 ; pub const XATTR_NAME_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const XATTR_SIZE_MAX : :: std :: os :: raw :: c_uint = 65536 ; pub const XATTR_LIST_MAX : :: std :: os :: raw :: c_uint = 65536 ; pub const RTSIG_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX_THREAD_KEYS_MAX : :: std :: os :: raw :: c_uint = 128 ; pub const PTHREAD_KEYS_MAX : :: std :: os :: raw :: c_uint = 1024 ; pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS : :: std :: os :: raw :: c_uint = 4 ; pub const PTHREAD_DESTRUCTOR_ITERATIONS : :: std :: os :: raw :: c_uint = 4 ; pub const _POSIX_THREAD_THREADS_MAX : :: std :: os :: raw :: c_uint = 64 ; pub const AIO_PRIO_DELTA_MAX : :: std :: os :: raw :: c_uint = 20 ; pub const PTHREAD_STACK_MIN : :: std :: os :: raw :: c_uint = 16384 ; pub const DELAYTIMER_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const TTY_NAME_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const LOGIN_NAME_MAX : :: std :: os :: raw :: c_uint = 256 ; pub const HOST_NAME_MAX : :: std :: os :: raw :: c_uint = 64 ; pub const MQ_PRIO_MAX : :: std :: os :: raw :: c_uint = 32768 ; pub const SEM_VALUE_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const _BITS_POSIX2_LIM_H : :: std :: os :: raw :: c_uint = 1 ; pub const _POSIX2_BC_BASE_MAX : :: std :: os :: raw :: c_uint = 99 ; pub const _POSIX2_BC_DIM_MAX : :: std :: os :: raw :: c_uint = 2048 ; pub const _POSIX2_BC_SCALE_MAX : :: std :: os :: raw :: c_uint = 99 ; pub const _POSIX2_BC_STRING_MAX : :: std :: os :: raw :: c_uint = 1000 ; pub const _POSIX2_COLL_WEIGHTS_MAX : :: std :: os :: raw :: c_uint = 2 ; pub const _POSIX2_EXPR_NEST_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX2_LINE_MAX : :: std :: os :: raw :: c_uint = 2048 ; pub const _POSIX2_RE_DUP_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX2_CHARCLASS_NAME_MAX : :: std :: os :: raw :: c_uint = 14 ; pub const BC_BASE_MAX : :: std :: os :: raw :: c_uint = 99 ; pub const BC_DIM_MAX : :: std :: os :: raw :: c_uint = 2048 ; pub const BC_SCALE_MAX : :: std :: os :: raw :: c_uint = 99 ; pub const BC_STRING_MAX : :: std :: os :: raw :: c_uint = 1000 ; pub const COLL_WEIGHTS_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const EXPR_NEST_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const LINE_MAX : :: std :: os :: raw :: c_uint = 2048 ; pub const CHARCLASS_NAME_MAX : :: std :: os :: raw :: c_uint = 2048 ; pub const RE_DUP_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const _BITS_SIGNUM_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_SIGNUM_GENERIC_H : :: std :: os :: raw :: c_uint = 1 ; pub const SIGINT : :: std :: os :: raw :: c_uint = 2 ; pub const SIGILL : :: std :: os :: raw :: c_uint = 4 ; pub const SIGABRT : :: std :: os :: raw :: c_uint = 6 ; pub const SIGFPE : :: std :: os :: raw :: c_uint = 8 ; pub const SIGSEGV : :: std :: os :: raw :: c_uint = 11 ; pub const SIGTERM : :: std :: os :: raw :: c_uint = 15 ; pub const SIGHUP : :: std :: os :: raw :: c_uint = 1 ; pub const SIGQUIT : :: std :: os :: raw :: c_uint = 3 ; pub const SIGTRAP : :: std :: os :: raw :: c_uint = 5 ; pub const SIGKILL : :: std :: os :: raw :: c_uint = 9 ; pub const SIGBUS : :: std :: os :: raw :: c_uint = 10 ; pub const SIGSYS : :: std :: os :: raw :: c_uint = 12 ; pub const SIGPIPE : :: std :: os :: raw :: c_uint = 13 ; pub const SIGALRM : :: std :: os :: raw :: c_uint = 14 ; pub const SIGURG : :: std :: os :: raw :: c_uint = 16 ; pub const SIGSTOP : :: std :: os :: raw :: c_uint = 17 ; pub const SIGTSTP : :: std :: os :: raw :: c_uint = 18 ; pub const SIGCONT : :: std :: os :: raw :: c_uint = 19 ; pub const SIGCHLD : :: std :: os :: raw :: c_uint = 20 ; pub const SIGTTIN : :: std :: os :: raw :: c_uint = 21 ; pub const SIGTTOU : :: std :: os :: raw :: c_uint = 22 ; pub const SIGPOLL : :: std :: os :: raw :: c_uint = 23 ; pub const SIGXCPU : :: std :: os :: raw :: c_uint = 24 ; pub const SIGXFSZ : :: std :: os :: raw :: c_uint = 25 ; pub const SIGVTALRM : :: std :: os :: raw :: c_uint = 26 ; pub const SIGPROF : :: std :: os :: raw :: c_uint = 27 ; pub const SIGUSR1 : :: std :: os :: raw :: c_uint = 30 ; pub const SIGUSR2 : :: std :: os :: raw :: c_uint = 31 ; pub const SIGWINCH : :: std :: os :: raw :: c_uint = 28 ; pub const SIGIO : :: std :: os :: raw :: c_uint = 23 ; pub const SIGIOT : :: std :: os :: raw :: c_uint = 6 ; pub const SIGCLD : :: std :: os :: raw :: c_uint = 20 ; pub const __SIGRTMIN : :: std :: os :: raw :: c_uint = 32 ; pub const __SIGRTMAX : :: std :: os :: raw :: c_uint = 32 ; pub const _NSIG : :: std :: os :: raw :: c_uint = 33 ; pub const SIGSTKFLT : :: std :: os :: raw :: c_uint = 16 ; pub const SIGPWR : :: std :: os :: raw :: c_uint = 30 ; pub const __sig_atomic_t_defined : :: std :: os :: raw :: c_uint = 1 ; pub const __siginfo_t_defined : :: std :: os :: raw :: c_uint = 1 ; pub const __SI_MAX_SIZE : :: std :: os :: raw :: c_uint = 128 ; pub const _BITS_SIGINFO_ARCH_H : :: std :: os :: raw :: c_uint = 1 ; pub const __SI_ERRNO_THEN_CODE : :: std :: os :: raw :: c_uint = 1 ; pub const __SI_HAVE_SIGSYS : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_SIGINFO_CONSTS_H : :: std :: os :: raw :: c_uint = 1 ; pub const __SI_ASYNCIO_AFTER_SIGIO : :: std :: os :: raw :: c_uint = 1 ; pub const __sigevent_t_defined : :: std :: os :: raw :: c_uint = 1 ; pub const __SIGEV_MAX_SIZE : :: std :: os :: raw :: c_uint = 64 ; pub const _BITS_SIGEVENT_CONSTS_H : :: std :: os :: raw :: c_uint = 1 ; pub const NSIG : :: std :: os :: raw :: c_uint = 33 ; pub const SA_NOCLDSTOP : :: std :: os :: raw :: c_uint = 1 ; pub const SA_NOCLDWAIT : :: std :: os :: raw :: c_uint = 2 ; pub const SA_SIGINFO : :: std :: os :: raw :: c_uint = 4 ; pub const SA_ONSTACK : :: std :: os :: raw :: c_uint = 134217728 ; pub const SA_RESTART : :: std :: os :: raw :: c_uint = 268435456 ; pub const SA_NODEFER : :: std :: os :: raw :: c_uint = 1073741824 ; pub const SA_RESETHAND : :: std :: os :: raw :: c_uint = 2147483648 ; pub const SA_INTERRUPT : :: std :: os :: raw :: c_uint = 536870912 ; pub const SA_NOMASK : :: std :: os :: raw :: c_uint = 1073741824 ; pub const SA_ONESHOT : :: std :: os :: raw :: c_uint = 2147483648 ; pub const SA_STACK : :: std :: os :: raw :: c_uint = 134217728 ; pub const SIG_BLOCK : :: std :: os :: raw :: c_uint = 0 ; pub const SIG_UNBLOCK : :: std :: os :: raw :: c_uint = 1 ; pub const SIG_SETMASK : :: std :: os :: raw :: c_uint = 2 ; pub const _BITS_SIGCONTEXT_H : :: std :: os :: raw :: c_uint = 1 ; pub const FP_XSTATE_MAGIC1 : :: std :: os :: raw :: c_uint = 1179670611 ; pub const FP_XSTATE_MAGIC2 : :: std :: os :: raw :: c_uint = 1179670597 ; pub const __stack_t_defined : :: std :: os :: raw :: c_uint = 1 ; pub const _SYS_UCONTEXT_H : :: std :: os :: raw :: c_uint = 1 ; pub const __NGREG : :: std :: os :: raw :: c_uint = 23 ; pub const NGREG : :: std :: os :: raw :: c_uint = 23 ; pub const _BITS_SIGSTACK_H : :: std :: os :: raw :: c_uint = 1 ; pub const MINSIGSTKSZ : :: std :: os :: raw :: c_uint = 2048 ; pub const SIGSTKSZ : :: std :: os :: raw :: c_uint = 8192 ; pub const _BITS_SS_FLAGS_H : :: std :: os :: raw :: c_uint = 1 ; pub const __sigstack_defined : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_SIGTHREAD_H : :: std :: os :: raw :: c_uint = 1 ; pub const HZ : :: std :: os :: raw :: c_uint = 100 ; pub const EXEC_PAGESIZE : :: std :: os :: raw :: c_uint = 4096 ; pub const NOGROUP : :: std :: os :: raw :: c_int = -1 ; pub const MAXHOSTNAMELEN : :: std :: os :: raw :: c_uint = 64 ; pub const MAXSYMLINKS : :: std :: os :: raw :: c_uint = 20 ; pub const NOFILE : :: std :: os :: raw :: c_uint = 256 ; pub const NCARGS : :: std :: os :: raw :: c_uint = 131072 ; pub const NGROUPS : :: std :: os :: raw :: c_uint = 65536 ; pub const CANBSIZ : :: std :: os :: raw :: c_uint = 255 ; pub const MAXPATHLEN : :: std :: os :: raw :: c_uint = 4096 ; pub const DEV_BSIZE : :: std :: os :: raw :: c_uint = 512 ; pub const _STDINT_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_WCHAR_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_STDINT_UINTN_H : :: std :: os :: raw :: c_uint = 1 ; pub const INT8_MIN : :: std :: os :: raw :: c_int = -128 ; pub const INT16_MIN : :: std :: os :: raw :: c_int = -32768 ; pub const INT32_MIN : :: std :: os :: raw :: c_int = -2147483648 ; pub const INT8_MAX : :: std :: os :: raw :: c_uint = 127 ; pub const INT16_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const INT32_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const UINT8_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const UINT16_MAX : :: std :: os :: raw :: c_uint = 65535 ; pub const UINT32_MAX : :: std :: os :: raw :: c_uint = 4294967295 ; pub const INT_LEAST8_MIN : :: std :: os :: raw :: c_int = -128 ; pub const INT_LEAST16_MIN : :: std :: os :: raw :: c_int = -32768 ; pub const INT_LEAST32_MIN : :: std :: os :: raw :: c_int = -2147483648 ; pub const INT_LEAST8_MAX : :: std :: os :: raw :: c_uint = 127 ; pub const INT_LEAST16_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const INT_LEAST32_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const UINT_LEAST8_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const UINT_LEAST16_MAX : :: std :: os :: raw :: c_uint = 65535 ; pub const UINT_LEAST32_MAX : :: std :: os :: raw :: c_uint = 4294967295 ; pub const INT_FAST8_MIN : :: std :: os :: raw :: c_int = -128 ; pub const INT_FAST16_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const INT_FAST32_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const INT_FAST8_MAX : :: std :: os :: raw :: c_uint = 127 ; pub const INT_FAST16_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const INT_FAST32_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const UINT_FAST8_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const UINT_FAST16_MAX : :: std :: os :: raw :: c_int = -1 ; pub const UINT_FAST32_MAX : :: std :: os :: raw :: c_int = -1 ; pub const INTPTR_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const INTPTR_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const UINTPTR_MAX : :: std :: os :: raw :: c_int = -1 ; pub const PTRDIFF_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const PTRDIFF_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const SIG_ATOMIC_MIN : :: std :: os :: raw :: c_int = -2147483648 ; pub const SIG_ATOMIC_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const SIZE_MAX : :: std :: os :: raw :: c_int = -1 ; pub const WINT_MIN : :: std :: os :: raw :: c_uint = 0 ; pub const WINT_MAX : :: std :: os :: raw :: c_uint = 4294967295 ; pub const LIBMODBUS_VERSION_MAJOR : :: std :: os :: raw :: c_uint = 3 ; pub const LIBMODBUS_VERSION_MINOR : :: std :: os :: raw :: c_uint = 1 ; pub const LIBMODBUS_VERSION_MICRO : :: std :: os :: raw :: c_uint = 4 ; pub const LIBMODBUS_VERSION_STRING : & 'static [ u8 ; 6usize ] = b"3.1.4\0" ; pub const LIBMODBUS_VERSION_HEX : :: std :: os :: raw :: c_uint = 196868 ; pub const FALSE : :: std :: os :: raw :: c_uint = 0 ; pub const TRUE : :: std :: os :: raw :: c_uint = 1 ; pub const OFF : :: std :: os :: raw :: c_uint = 0 ; pub const ON : :: std :: os :: raw :: c_uint = 1 ; pub const MODBUS_FC_READ_COILS : :: std :: os :: raw :: c_uint = 1 ; pub const MODBUS_FC_READ_DISCRETE_INPUTS : :: std :: os :: raw :: c_uint = 2 ; pub const MODBUS_FC_READ_HOLDING_REGISTERS : :: std :: os :: raw :: c_uint = 3 ; pub const MODBUS_FC_READ_INPUT_REGISTERS : :: std :: os :: raw :: c_uint = 4 ; pub const MODBUS_FC_WRITE_SINGLE_COIL : :: std :: os :: raw :: c_uint = 5 ; pub const MODBUS_FC_WRITE_SINGLE_REGISTER : :: std :: os :: raw :: c_uint = 6 ; pub const MODBUS_FC_READ_EXCEPTION_STATUS : :: std :: os :: raw :: c_uint = 7 ; pub const MODBUS_FC_WRITE_MULTIPLE_COILS : :: std :: os :: raw :: c_uint = 15 ; pub const MODBUS_FC_WRITE_MULTIPLE_REGISTERS : :: std :: os :: raw :: c_uint = 16 ; pub const MODBUS_FC_REPORT_SLAVE_ID : :: std :: os :: raw :: c_uint = 17 ; pub const MODBUS_FC_MASK_WRITE_REGISTER : :: std :: os :: raw :: c_uint = 22 ; pub const MODBUS_FC_WRITE_AND_READ_REGISTERS : :: std :: os :: raw :: c_uint = 23 ; pub const MODBUS_BROADCAST_ADDRESS : :: std :: os :: raw :: c_uint = 0 ; pub const MODBUS_MAX_READ_BITS : :: std :: os :: raw :: c_uint = 2000 ; pub const MODBUS_MAX_WRITE_BITS : :: std :: os :: raw :: c_uint = 1968 ; pub const MODBUS_MAX_READ_REGISTERS : :: std :: os :: raw :: c_uint = 125 ; pub const MODBUS_MAX_WRITE_REGISTERS : :: std :: os :: raw :: c_uint = 123 ; pub const MODBUS_MAX_WR_WRITE_REGISTERS : :: std :: os :: raw :: c_uint = 121 ; pub const MODBUS_MAX_WR_READ_REGISTERS : :: std :: os :: raw :: c_uint = 125 ; pub const MODBUS_MAX_PDU_LENGTH : :: std :: os :: raw :: c_uint = 253 ; pub const MODBUS_MAX_ADU_LENGTH : :: std :: os :: raw :: c_uint = 260 ; pub const MODBUS_ENOBASE : :: std :: os :: raw :: c_uint = 112345678 ; pub const MODBUS_TCP_DEFAULT_PORT : :: std :: os :: raw :: c_uint = 502 ; pub const MODBUS_TCP_SLAVE : :: std :: os :: raw :: c_uint = 255 ; pub const MODBUS_TCP_MAX_ADU_LENGTH : :: std :: os :: raw :: c_uint = 260 ; pub const MODBUS_RTU_MAX_ADU_LENGTH : :: std :: os :: raw :: c_uint = 256 ; pub const MODBUS_RTU_RS232 : :: std :: os :: raw :: c_uint = 0 ; pub const MODBUS_RTU_RS485 : :: std :: os :: raw :: c_uint = 1 ; pub const MODBUS_RTU_RTS_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const MODBUS_RTU_RTS_UP : :: std :: os :: raw :: c_uint = 1 ; pub const MODBUS_RTU_RTS_DOWN : :: std :: os :: raw :: c_uint = 2 ; pub type __u_char = :: std :: os :: raw :: c_uchar ; pub type __u_short = :: std :: os :: raw :: c_ushort ; pub type __u_int = :: std :: os :: raw :: c_uint ; pub type __u_long = :: std :: os :: raw :: c_ulong ; pub type __int8_t = :: std :: os :: raw :: c_schar ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __int16_t = :: std :: os :: raw :: c_short ; pub type __uint16_t = :: std :: os :: raw :: c_ushort ; pub type __int32_t = :: std :: os :: raw :: c_int ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_long ; pub type __uint64_t = :: std :: os :: raw :: c_ulong ; pub type __quad_t = :: std :: os :: raw :: c_long ; pub type __u_quad_t = :: std :: os :: raw :: c_ulong ; pub type __intmax_t = :: std :: os :: raw :: c_long ; pub type __uintmax_t = :: std :: os :: raw :: c_ulong ; pub type __dev_t = :: std :: os :: raw :: c_ulong ; pub type __uid_t = :: std :: os :: raw :: c_uint ; pub type __gid_t = :: std :: os :: raw :: c_uint ; pub type __ino_t = :: std :: os :: raw :: c_ulong ; pub type __ino64_t = :: std :: os :: raw :: c_ulong ; pub type __mode_t = :: std :: os :: raw :: c_uint ; pub type __nlink_t = :: std :: os :: raw :: c_ulong ; pub type __off_t = :: std :: os :: raw :: c_long ; pub type __off64_t = :: std :: os :: raw :: c_long ; pub type __pid_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __fsid_t { pub __val : [ :: std :: os :: raw :: c_int ; 2usize ] , } # [ test ] fn bindgen_test_layout___fsid_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __fsid_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __fsid_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __fsid_t ) , "::" , stringify ! ( __val ) ) ) ; } pub type __clock_t = :: std :: os :: raw :: c_long ; pub type __rlim_t = :: std :: os :: raw :: c_ulong ; pub type __rlim64_t = :: std :: os :: raw :: c_ulong ; pub type __id_t = :: std :: os :: raw :: c_uint ; pub type __time_t = :: std :: os :: raw :: c_long ; pub type __useconds_t = :: std :: os :: raw :: c_uint ; pub type __suseconds_t = :: std :: os :: raw :: c_long ; pub type __daddr_t = :: std :: os :: raw :: c_int ; pub type __key_t = :: std :: os :: raw :: c_int ; pub type __clockid_t = :: std :: os :: raw :: c_int ; pub type __timer_t = * mut :: std :: os :: raw :: c_void ; pub type __blksize_t = :: std :: os :: raw :: c_long ; pub type __blkcnt_t = :: std :: os :: raw :: c_long ; pub type __blkcnt64_t = :: std :: os :: raw :: c_long ; pub type __fsblkcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsblkcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsword_t = :: std :: os :: raw :: c_long ; pub type __ssize_t = :: std :: os :: raw :: c_long ; pub type __syscall_slong_t = :: std :: os :: raw :: c_long ; pub type __syscall_ulong_t = :: std :: os :: raw :: c_ulong ; pub type __loff_t = __off64_t ; pub type __qaddr_t = * mut __quad_t ; pub type __caddr_t = * mut :: std :: os :: raw :: c_char ; pub type __intptr_t = :: std :: os :: raw :: c_long ; pub type __socklen_t = :: std :: os :: raw :: c_uint ; pub type __sig_atomic_t = :: std :: os :: raw :: c_int ; pub type u_char = __u_char ; pub type u_short = __u_short ; pub type u_int = __u_int ; pub type u_long = __u_long ; pub type quad_t = __quad_t ; pub type u_quad_t = __u_quad_t ; pub type fsid_t = __fsid_t ; pub type loff_t = __loff_t ; pub type ino_t = __ino_t ; pub type dev_t = __dev_t ; pub type gid_t = __gid_t ; pub type mode_t = __mode_t ; pub type nlink_t = __nlink_t ; pub type uid_t = __uid_t ; pub type off_t = __off_t ; pub type pid_t = __pid_t ; pub type id_t = __id_t ; pub type daddr_t = __daddr_t ; pub type caddr_t = __caddr_t ; pub type key_t = __key_t ; pub type clock_t = __clock_t ; pub type clockid_t = __clockid_t ; pub type time_t = __time_t ; pub type timer_t = __timer_t ; pub type ulong = :: std :: os :: raw :: c_ulong ; pub type ushort = :: std :: os :: raw :: c_ushort ; pub type uint = :: std :: os :: raw :: c_uint ; pub type u_int8_t = :: std :: os :: raw :: c_uchar ; pub type u_int16_t = :: std :: os :: raw :: c_ushort ; pub type u_int32_t = :: std :: os :: raw :: c_uint ; pub type u_int64_t = :: std :: os :: raw :: c_ulong ; pub type register_t = :: std :: os :: raw :: c_long ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __sigset_t { pub __val : [ :: std :: os :: raw :: c_ulong ; 16usize ] , } # [ test ] fn bindgen_test_layout___sigset_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __sigset_t > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( __sigset_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __sigset_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __sigset_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __sigset_t ) , "::" , stringify ! ( __val ) ) ) ; } pub type sigset_t = __sigset_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct timeval { pub tv_sec : __time_t , pub tv_usec : __suseconds_t , } # [ test ] fn bindgen_test_layout_timeval ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timeval > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timeval ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < timeval > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timeval ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( timeval ) , "::" , stringify ! ( tv_sec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( timeval ) , "::" , stringify ! ( tv_usec ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct timespec { pub tv_sec : __time_t , pub tv_nsec : __syscall_slong_t , } # [ test ] fn bindgen_test_layout_timespec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timespec > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timespec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < timespec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timespec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_sec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_nsec ) ) ) ; } pub type suseconds_t = __suseconds_t ; pub type __fd_mask = :: std :: os :: raw :: c_long ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct fd_set { pub __fds_bits : [ __fd_mask ; 16usize ] , } # [ test ] fn bindgen_test_layout_fd_set ( ) { assert_eq ! ( :: std :: mem :: size_of :: < fd_set > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( fd_set ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < fd_set > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( fd_set ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( fd_set ) , "::" , stringify ! ( __fds_bits ) ) ) ; } pub type fd_mask = __fd_mask ; extern "C" {
 pub fn select ( __nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * mut timeval , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn pselect ( __nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * const timespec , __sigmask : * const __sigset_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn gnu_dev_major ( __dev : __dev_t , ) -> :: std :: os :: raw :: c_uint ; 
} extern "C" {
 pub fn gnu_dev_minor ( __dev : __dev_t , ) -> :: std :: os :: raw :: c_uint ; 
} extern "C" {
 pub fn gnu_dev_makedev ( __major : :: std :: os :: raw :: c_uint , __minor : :: std :: os :: raw :: c_uint , ) -> __dev_t ; 
} pub type blksize_t = __blksize_t ; pub type blkcnt_t = __blkcnt_t ; pub type fsblkcnt_t = __fsblkcnt_t ; pub type fsfilcnt_t = __fsfilcnt_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_rwlock_arch_t { pub __readers : :: std :: os :: raw :: c_uint , pub __writers : :: std :: os :: raw :: c_uint , pub __wrphase_futex : :: std :: os :: raw :: c_uint , pub __writers_futex : :: std :: os :: raw :: c_uint , pub __pad3 : :: std :: os :: raw :: c_uint , pub __pad4 : :: std :: os :: raw :: c_uint , pub __cur_writer : :: std :: os :: raw :: c_int , pub __shared : :: std :: os :: raw :: c_int , pub __rwelision : :: std :: os :: raw :: c_schar , pub __pad1 : [ :: std :: os :: raw :: c_uchar ; 7usize ] , pub __pad2 : :: std :: os :: raw :: c_ulong , pub __flags : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___pthread_rwlock_arch_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_rwlock_arch_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( __pthread_rwlock_arch_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_rwlock_arch_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_rwlock_arch_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __readers as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __readers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __writers as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __writers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __wrphase_futex as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __wrphase_futex ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __writers_futex as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __writers_futex ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __pad3 as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __pad3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __pad4 as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __pad4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __cur_writer as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __cur_writer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __shared as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __shared ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __rwelision as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __rwelision ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __pad1 as * const _ as usize } , 33usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __pad1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __pad2 as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __pad2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __flags as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __flags ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_internal_list { pub __prev : * mut __pthread_internal_list , pub __next : * mut __pthread_internal_list , } # [ test ] fn bindgen_test_layout___pthread_internal_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_internal_list > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __pthread_internal_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_internal_list > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_internal_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_internal_list ) ) . __next as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __next ) ) ) ; } pub type __pthread_list_t = __pthread_internal_list ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_mutex_s { pub __lock : :: std :: os :: raw :: c_int , pub __count : :: std :: os :: raw :: c_uint , pub __owner : :: std :: os :: raw :: c_int , pub __nusers : :: std :: os :: raw :: c_uint , pub __kind : :: std :: os :: raw :: c_int , pub __spins : :: std :: os :: raw :: c_short , pub __elision : :: std :: os :: raw :: c_short , pub __list : __pthread_list_t , } # [ test ] fn bindgen_test_layout___pthread_mutex_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_mutex_s > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( __pthread_mutex_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_mutex_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_mutex_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_mutex_s ) ) . __lock as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_mutex_s ) ) . __count as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __count ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_mutex_s ) ) . __owner as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __owner ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_mutex_s ) ) . __nusers as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __nusers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_mutex_s ) ) . __kind as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __kind ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_mutex_s ) ) . __spins as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __spins ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_mutex_s ) ) . __elision as * const _ as usize } , 22usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __elision ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_mutex_s ) ) . __list as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __list ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __pthread_cond_s { pub __bindgen_anon_1 : __pthread_cond_s__bindgen_ty_1 , pub __bindgen_anon_2 : __pthread_cond_s__bindgen_ty_2 , pub __g_refs : [ :: std :: os :: raw :: c_uint ; 2usize ] , pub __g_size : [ :: std :: os :: raw :: c_uint ; 2usize ] , pub __g1_orig_size : :: std :: os :: raw :: c_uint , pub __wrefs : :: std :: os :: raw :: c_uint , pub __g_signals : [ :: std :: os :: raw :: c_uint ; 2usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __pthread_cond_s__bindgen_ty_1 { pub __wseq : :: std :: os :: raw :: c_ulonglong , pub __wseq32 : __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 { pub __low : :: std :: os :: raw :: c_uint , pub __high : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ) . __low as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( __low ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ) . __high as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( __high ) ) ) ; } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_1 ) ) . __wseq as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) , "::" , stringify ! ( __wseq ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_1 ) ) . __wseq32 as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) , "::" , stringify ! ( __wseq32 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __pthread_cond_s__bindgen_ty_2 { pub __g1_start : :: std :: os :: raw :: c_ulonglong , pub __g1_start32 : __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 { pub __low : :: std :: os :: raw :: c_uint , pub __high : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ) . __low as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! ( __low ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ) . __high as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! ( __high ) ) ) ; } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_2 ) ) . __g1_start as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) , "::" , stringify ! ( __g1_start ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_2 ) ) . __g1_start32 as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) , "::" , stringify ! ( __g1_start32 ) ) ) ; } # [ test ] fn bindgen_test_layout___pthread_cond_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s ) ) . __g_refs as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g_refs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s ) ) . __g_size as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s ) ) . __g1_orig_size as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g1_orig_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s ) ) . __wrefs as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __wrefs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s ) ) . __g_signals as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g_signals ) ) ) ; } pub type pthread_t = :: std :: os :: raw :: c_ulong ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutexattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_mutexattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutexattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_condattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_condattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_condattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_condattr_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_condattr_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( __align ) ) ) ; } pub type pthread_key_t = :: std :: os :: raw :: c_uint ; pub type pthread_once_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_attr_t { pub __size : [ :: std :: os :: raw :: c_char ; 56usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 7usize ] , } # [ test ] fn bindgen_test_layout_pthread_attr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_attr_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_attr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_attr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_attr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutex_t { pub __data : __pthread_mutex_s , pub __size : [ :: std :: os :: raw :: c_char ; 40usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 5usize ] , } # [ test ] fn bindgen_test_layout_pthread_mutex_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutex_t > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutex_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_cond_t { pub __data : __pthread_cond_s , pub __size : [ :: std :: os :: raw :: c_char ; 48usize ] , pub __align : :: std :: os :: raw :: c_longlong , _bindgen_union_align : [ u64 ; 6usize ] , } # [ test ] fn bindgen_test_layout_pthread_cond_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_cond_t > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_cond_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlock_t { pub __data : __pthread_rwlock_arch_t , pub __size : [ :: std :: os :: raw :: c_char ; 56usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 7usize ] , } # [ test ] fn bindgen_test_layout_pthread_rwlock_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlock_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlock_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlock_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlockattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 8usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_pthread_rwlockattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlockattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlockattr_t ) , "::" , stringify ! ( __align ) ) ) ; } pub type pthread_spinlock_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrier_t { pub __size : [ :: std :: os :: raw :: c_char ; 32usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 4usize ] , } # [ test ] fn bindgen_test_layout_pthread_barrier_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrier_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( pthread_barrier_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrier_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_barrier_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_barrier_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_barrier_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrierattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_barrierattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrierattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_barrierattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_barrierattr_t ) , "::" , stringify ! ( __align ) ) ) ; } pub type sig_atomic_t = __sig_atomic_t ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigval { pub sival_int : :: std :: os :: raw :: c_int , pub sival_ptr : * mut :: std :: os :: raw :: c_void , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_sigval ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigval > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( sigval ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigval > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigval ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigval ) ) . sival_int as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigval ) , "::" , stringify ! ( sival_int ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigval ) ) . sival_ptr as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigval ) , "::" , stringify ! ( sival_ptr ) ) ) ; } pub type sigval_t = sigval ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t { pub si_signo : :: std :: os :: raw :: c_int , pub si_errno : :: std :: os :: raw :: c_int , pub si_code : :: std :: os :: raw :: c_int , pub __pad0 : :: std :: os :: raw :: c_int , pub _sifields : siginfo_t__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union siginfo_t__bindgen_ty_1 { pub _pad : [ :: std :: os :: raw :: c_int ; 28usize ] , pub _kill : siginfo_t__bindgen_ty_1__bindgen_ty_1 , pub _timer : siginfo_t__bindgen_ty_1__bindgen_ty_2 , pub _rt : siginfo_t__bindgen_ty_1__bindgen_ty_3 , pub _sigchld : siginfo_t__bindgen_ty_1__bindgen_ty_4 , pub _sigfault : siginfo_t__bindgen_ty_1__bindgen_ty_5 , pub _sigpoll : siginfo_t__bindgen_ty_1__bindgen_ty_6 , pub _sigsys : siginfo_t__bindgen_ty_1__bindgen_ty_7 , _bindgen_union_align : [ u64 ; 14usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 { pub si_pid : __pid_t , pub si_uid : __uid_t , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ) . si_pid as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( si_pid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ) . si_uid as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( si_uid ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 { pub si_tid : :: std :: os :: raw :: c_int , pub si_overrun : :: std :: os :: raw :: c_int , pub si_sigval : sigval_t , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_2 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ) . si_tid as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! ( si_tid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ) . si_overrun as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! ( si_overrun ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ) . si_sigval as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! ( si_sigval ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 { pub si_pid : __pid_t , pub si_uid : __uid_t , pub si_sigval : sigval_t , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_3 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_3 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ) . si_pid as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! ( si_pid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ) . si_uid as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! ( si_uid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ) . si_sigval as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! ( si_sigval ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 { pub si_pid : __pid_t , pub si_uid : __uid_t , pub si_status : :: std :: os :: raw :: c_int , pub si_utime : __clock_t , pub si_stime : __clock_t , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_4 > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_4 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ) . si_pid as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! ( si_pid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ) . si_uid as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! ( si_uid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ) . si_status as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! ( si_status ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ) . si_utime as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! ( si_utime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ) . si_stime as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! ( si_stime ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 { pub si_addr : * mut :: std :: os :: raw :: c_void , pub si_addr_lsb : :: std :: os :: raw :: c_short , pub _bounds : siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 { pub _addr_bnd : siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 , pub _pkey : __uint32_t , _bindgen_union_align : [ u64 ; 2usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 { pub _lower : * mut :: std :: os :: raw :: c_void , pub _upper : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 ) ) . _lower as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _lower ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 ) ) . _upper as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _upper ) ) ) ; } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ) . _addr_bnd as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) , "::" , stringify ! ( _addr_bnd ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ) . _pkey as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) , "::" , stringify ! ( _pkey ) ) ) ; } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_5 > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_5 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ) . si_addr as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! ( si_addr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ) . si_addr_lsb as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! ( si_addr_lsb ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ) . _bounds as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! ( _bounds ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 { pub si_band : :: std :: os :: raw :: c_long , pub si_fd : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_6 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_6 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ) . si_band as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! ( si_band ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ) . si_fd as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! ( si_fd ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 { pub _call_addr : * mut :: std :: os :: raw :: c_void , pub _syscall : :: std :: os :: raw :: c_int , pub _arch : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_7 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_7 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ) . _call_addr as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! ( _call_addr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ) . _syscall as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! ( _syscall ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ) . _arch as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! ( _arch ) ) ) ; } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1 > ( ) , 112usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _pad as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1 ) , "::" , stringify ! ( _pad ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _kill as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1 ) , "::" , stringify ! ( _kill ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _timer as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1 ) , "::" , stringify ! ( _timer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _rt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1 ) , "::" , stringify ! ( _rt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigchld as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1 ) , "::" , stringify ! ( _sigchld ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigfault as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1 ) , "::" , stringify ! ( _sigfault ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigpoll as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1 ) , "::" , stringify ! ( _sigpoll ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigsys as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1 ) , "::" , stringify ! ( _sigsys ) ) ) ; } # [ test ] fn bindgen_test_layout_siginfo_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( siginfo_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t ) ) . si_signo as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t ) , "::" , stringify ! ( si_signo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t ) ) . si_errno as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t ) , "::" , stringify ! ( si_errno ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t ) ) . si_code as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t ) , "::" , stringify ! ( si_code ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t ) ) . __pad0 as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t ) , "::" , stringify ! ( __pad0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const siginfo_t ) ) . _sifields as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( siginfo_t ) , "::" , stringify ! ( _sifields ) ) ) ; } pub const SI_ASYNCNL : _bindgen_ty_1 = -60 ; pub const SI_TKILL : _bindgen_ty_1 = -6 ; pub const SI_SIGIO : _bindgen_ty_1 = -5 ; pub const SI_ASYNCIO : _bindgen_ty_1 = -4 ; pub const SI_MESGQ : _bindgen_ty_1 = -3 ; pub const SI_TIMER : _bindgen_ty_1 = -2 ; pub const SI_QUEUE : _bindgen_ty_1 = -1 ; pub const SI_USER : _bindgen_ty_1 = 0 ; pub const SI_KERNEL : _bindgen_ty_1 = 128 ; pub type _bindgen_ty_1 = :: std :: os :: raw :: c_int ; pub const ILL_ILLOPC : _bindgen_ty_2 = 1 ; pub const ILL_ILLOPN : _bindgen_ty_2 = 2 ; pub const ILL_ILLADR : _bindgen_ty_2 = 3 ; pub const ILL_ILLTRP : _bindgen_ty_2 = 4 ; pub const ILL_PRVOPC : _bindgen_ty_2 = 5 ; pub const ILL_PRVREG : _bindgen_ty_2 = 6 ; pub const ILL_COPROC : _bindgen_ty_2 = 7 ; pub const ILL_BADSTK : _bindgen_ty_2 = 8 ; pub type _bindgen_ty_2 = :: std :: os :: raw :: c_uint ; pub const FPE_INTDIV : _bindgen_ty_3 = 1 ; pub const FPE_INTOVF : _bindgen_ty_3 = 2 ; pub const FPE_FLTDIV : _bindgen_ty_3 = 3 ; pub const FPE_FLTOVF : _bindgen_ty_3 = 4 ; pub const FPE_FLTUND : _bindgen_ty_3 = 5 ; pub const FPE_FLTRES : _bindgen_ty_3 = 6 ; pub const FPE_FLTINV : _bindgen_ty_3 = 7 ; pub const FPE_FLTSUB : _bindgen_ty_3 = 8 ; pub type _bindgen_ty_3 = :: std :: os :: raw :: c_uint ; pub const SEGV_MAPERR : _bindgen_ty_4 = 1 ; pub const SEGV_ACCERR : _bindgen_ty_4 = 2 ; pub type _bindgen_ty_4 = :: std :: os :: raw :: c_uint ; pub const BUS_ADRALN : _bindgen_ty_5 = 1 ; pub const BUS_ADRERR : _bindgen_ty_5 = 2 ; pub const BUS_OBJERR : _bindgen_ty_5 = 3 ; pub const BUS_MCEERR_AR : _bindgen_ty_5 = 4 ; pub const BUS_MCEERR_AO : _bindgen_ty_5 = 5 ; pub type _bindgen_ty_5 = :: std :: os :: raw :: c_uint ; pub const CLD_EXITED : _bindgen_ty_6 = 1 ; pub const CLD_KILLED : _bindgen_ty_6 = 2 ; pub const CLD_DUMPED : _bindgen_ty_6 = 3 ; pub const CLD_TRAPPED : _bindgen_ty_6 = 4 ; pub const CLD_STOPPED : _bindgen_ty_6 = 5 ; pub const CLD_CONTINUED : _bindgen_ty_6 = 6 ; pub type _bindgen_ty_6 = :: std :: os :: raw :: c_uint ; pub const POLL_IN : _bindgen_ty_7 = 1 ; pub const POLL_OUT : _bindgen_ty_7 = 2 ; pub const POLL_MSG : _bindgen_ty_7 = 3 ; pub const POLL_ERR : _bindgen_ty_7 = 4 ; pub const POLL_PRI : _bindgen_ty_7 = 5 ; pub const POLL_HUP : _bindgen_ty_7 = 6 ; pub type _bindgen_ty_7 = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigevent { pub sigev_value : sigval_t , pub sigev_signo : :: std :: os :: raw :: c_int , pub sigev_notify : :: std :: os :: raw :: c_int , pub _sigev_un : sigevent__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigevent__bindgen_ty_1 { pub _pad : [ :: std :: os :: raw :: c_int ; 12usize ] , pub _tid : __pid_t , pub _sigev_thread : sigevent__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : [ u64 ; 6usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigevent__bindgen_ty_1__bindgen_ty_1 { pub _function : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : sigval_t ) > , pub _attribute : * mut pthread_attr_t , } # [ test ] fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigevent__bindgen_ty_1__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sigevent__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigevent__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigevent__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigevent__bindgen_ty_1__bindgen_ty_1 ) ) . _function as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _function ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigevent__bindgen_ty_1__bindgen_ty_1 ) ) . _attribute as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _attribute ) ) ) ; } # [ test ] fn bindgen_test_layout_sigevent__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigevent__bindgen_ty_1 > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( sigevent__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigevent__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigevent__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) . _pad as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1 ) , "::" , stringify ! ( _pad ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) . _tid as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1 ) , "::" , stringify ! ( _tid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) . _sigev_thread as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1 ) , "::" , stringify ! ( _sigev_thread ) ) ) ; } # [ test ] fn bindgen_test_layout_sigevent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigevent > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( sigevent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigevent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigevent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigevent ) ) . sigev_value as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigevent ) , "::" , stringify ! ( sigev_value ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigevent ) ) . sigev_signo as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( sigevent ) , "::" , stringify ! ( sigev_signo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigevent ) ) . sigev_notify as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( sigevent ) , "::" , stringify ! ( sigev_notify ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigevent ) ) . _sigev_un as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( sigevent ) , "::" , stringify ! ( _sigev_un ) ) ) ; } pub type sigevent_t = sigevent ; pub const SIGEV_SIGNAL : _bindgen_ty_8 = 0 ; pub const SIGEV_NONE : _bindgen_ty_8 = 1 ; pub const SIGEV_THREAD : _bindgen_ty_8 = 2 ; pub const SIGEV_THREAD_ID : _bindgen_ty_8 = 4 ; pub type _bindgen_ty_8 = :: std :: os :: raw :: c_uint ; pub type __sighandler_t = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : :: std :: os :: raw :: c_int ) > ; extern "C" {
 pub fn __sysv_signal ( __sig : :: std :: os :: raw :: c_int , __handler : __sighandler_t , ) -> __sighandler_t ; 
} extern "C" {
 pub fn signal ( __sig : :: std :: os :: raw :: c_int , __handler : __sighandler_t , ) -> __sighandler_t ; 
} extern "C" {
 pub fn kill ( __pid : __pid_t , __sig : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn killpg ( __pgrp : __pid_t , __sig : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn raise ( __sig : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn ssignal ( __sig : :: std :: os :: raw :: c_int , __handler : __sighandler_t , ) -> __sighandler_t ; 
} extern "C" {
 pub fn gsignal ( __sig : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn psignal ( __sig : :: std :: os :: raw :: c_int , __s : * const :: std :: os :: raw :: c_char , ) ; 
} extern "C" {
 pub fn psiginfo ( __pinfo : * const siginfo_t , __s : * const :: std :: os :: raw :: c_char , ) ; 
} extern "C" {
 pub fn sigblock ( __mask : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn sigsetmask ( __mask : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn siggetmask ( ) -> :: std :: os :: raw :: c_int ; 
} pub type sig_t = __sighandler_t ; extern "C" {
 pub fn sigemptyset ( __set : * mut sigset_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn sigfillset ( __set : * mut sigset_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn sigaddset ( __set : * mut sigset_t , __signo : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn sigdelset ( __set : * mut sigset_t , __signo : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn sigismember ( __set : * const sigset_t , __signo : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigaction { pub __sigaction_handler : sigaction__bindgen_ty_1 , pub sa_mask : __sigset_t , pub sa_flags : :: std :: os :: raw :: c_int , pub sa_restorer : :: std :: option :: Option < unsafe extern "C" fn ( ) > , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigaction__bindgen_ty_1 { pub sa_handler : __sighandler_t , pub sa_sigaction : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : :: std :: os :: raw :: c_int , arg2 : * mut siginfo_t , arg3 : * mut :: std :: os :: raw :: c_void ) > , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_sigaction__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigaction__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( sigaction__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigaction__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigaction__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigaction__bindgen_ty_1 ) ) . sa_handler as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigaction__bindgen_ty_1 ) , "::" , stringify ! ( sa_handler ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigaction__bindgen_ty_1 ) ) . sa_sigaction as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigaction__bindgen_ty_1 ) , "::" , stringify ! ( sa_sigaction ) ) ) ; } # [ test ] fn bindgen_test_layout_sigaction ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigaction > ( ) , 152usize , concat ! ( "Size of: " , stringify ! ( sigaction ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigaction > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigaction ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigaction ) ) . __sigaction_handler as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigaction ) , "::" , stringify ! ( __sigaction_handler ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigaction ) ) . sa_mask as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( sigaction ) , "::" , stringify ! ( sa_mask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigaction ) ) . sa_flags as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( sigaction ) , "::" , stringify ! ( sa_flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigaction ) ) . sa_restorer as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( sigaction ) , "::" , stringify ! ( sa_restorer ) ) ) ; } extern "C" {
 pub fn sigprocmask ( __how : :: std :: os :: raw :: c_int , __set : * const sigset_t , __oset : * mut sigset_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn sigsuspend ( __set : * const sigset_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn sigaction ( __sig : :: std :: os :: raw :: c_int , __act : * const sigaction , __oact : * mut sigaction , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn sigpending ( __set : * mut sigset_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn sigwait ( __set : * const sigset_t , __sig : * mut :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn sigwaitinfo ( __set : * const sigset_t , __info : * mut siginfo_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn sigtimedwait ( __set : * const sigset_t , __info : * mut siginfo_t , __timeout : * const timespec , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn sigqueue ( __pid : __pid_t , __sig : :: std :: os :: raw :: c_int , __val : sigval , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 # [ link_name = "\u{1}_sys_siglist" ] 
 pub static mut  _sys_siglist  :  [ * const :: std :: os :: raw :: c_char ; 65usize ] ;
} extern "C" {
 # [ link_name = "\u{1}sys_siglist" ] 
 pub static mut  sys_siglist  :  [ * const :: std :: os :: raw :: c_char ; 65usize ] ;
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _fpx_sw_bytes { pub magic1 : __uint32_t , pub extended_size : __uint32_t , pub xstate_bv : __uint64_t , pub xstate_size : __uint32_t , pub __glibc_reserved1 : [ __uint32_t ; 7usize ] , } # [ test ] fn bindgen_test_layout__fpx_sw_bytes ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _fpx_sw_bytes > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( _fpx_sw_bytes ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _fpx_sw_bytes > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _fpx_sw_bytes ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpx_sw_bytes ) ) . magic1 as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::" , stringify ! ( magic1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpx_sw_bytes ) ) . extended_size as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::" , stringify ! ( extended_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpx_sw_bytes ) ) . xstate_bv as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::" , stringify ! ( xstate_bv ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpx_sw_bytes ) ) . xstate_size as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::" , stringify ! ( xstate_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpx_sw_bytes ) ) . __glibc_reserved1 as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::" , stringify ! ( __glibc_reserved1 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _fpreg { pub significand : [ :: std :: os :: raw :: c_ushort ; 4usize ] , pub exponent : :: std :: os :: raw :: c_ushort , } # [ test ] fn bindgen_test_layout__fpreg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _fpreg > ( ) , 10usize , concat ! ( "Size of: " , stringify ! ( _fpreg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _fpreg > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( _fpreg ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpreg ) ) . significand as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _fpreg ) , "::" , stringify ! ( significand ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpreg ) ) . exponent as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _fpreg ) , "::" , stringify ! ( exponent ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _fpxreg { pub significand : [ :: std :: os :: raw :: c_ushort ; 4usize ] , pub exponent : :: std :: os :: raw :: c_ushort , pub __glibc_reserved1 : [ :: std :: os :: raw :: c_ushort ; 3usize ] , } # [ test ] fn bindgen_test_layout__fpxreg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _fpxreg > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _fpxreg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _fpxreg > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( _fpxreg ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpxreg ) ) . significand as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _fpxreg ) , "::" , stringify ! ( significand ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpxreg ) ) . exponent as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _fpxreg ) , "::" , stringify ! ( exponent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpxreg ) ) . __glibc_reserved1 as * const _ as usize } , 10usize , concat ! ( "Alignment of field: " , stringify ! ( _fpxreg ) , "::" , stringify ! ( __glibc_reserved1 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmmreg { pub element : [ __uint32_t ; 4usize ] , } # [ test ] fn bindgen_test_layout__xmmreg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmmreg > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _xmmreg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmmreg > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( _xmmreg ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmmreg ) ) . element as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmmreg ) , "::" , stringify ! ( element ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _fpstate { pub cwd : __uint16_t , pub swd : __uint16_t , pub ftw : __uint16_t , pub fop : __uint16_t , pub rip : __uint64_t , pub rdp : __uint64_t , pub mxcsr : __uint32_t , pub mxcr_mask : __uint32_t , pub _st : [ _fpxreg ; 8usize ] , pub _xmm : [ _xmmreg ; 16usize ] , pub __glibc_reserved1 : [ __uint32_t ; 24usize ] , } # [ test ] fn bindgen_test_layout__fpstate ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _fpstate > ( ) , 512usize , concat ! ( "Size of: " , stringify ! ( _fpstate ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _fpstate > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _fpstate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpstate ) ) . cwd as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( cwd ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpstate ) ) . swd as * const _ as usize } , 2usize , concat ! ( "Alignment of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( swd ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpstate ) ) . ftw as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( ftw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpstate ) ) . fop as * const _ as usize } , 6usize , concat ! ( "Alignment of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( fop ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpstate ) ) . rip as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( rip ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpstate ) ) . rdp as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( rdp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpstate ) ) . mxcsr as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( mxcsr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpstate ) ) . mxcr_mask as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( mxcr_mask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpstate ) ) . _st as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( _st ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpstate ) ) . _xmm as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( _xmm ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _fpstate ) ) . __glibc_reserved1 as * const _ as usize } , 416usize , concat ! ( "Alignment of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( __glibc_reserved1 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigcontext { pub r8 : __uint64_t , pub r9 : __uint64_t , pub r10 : __uint64_t , pub r11 : __uint64_t , pub r12 : __uint64_t , pub r13 : __uint64_t , pub r14 : __uint64_t , pub r15 : __uint64_t , pub rdi : __uint64_t , pub rsi : __uint64_t , pub rbp : __uint64_t , pub rbx : __uint64_t , pub rdx : __uint64_t , pub rax : __uint64_t , pub rcx : __uint64_t , pub rsp : __uint64_t , pub rip : __uint64_t , pub eflags : __uint64_t , pub cs : :: std :: os :: raw :: c_ushort , pub gs : :: std :: os :: raw :: c_ushort , pub fs : :: std :: os :: raw :: c_ushort , pub __pad0 : :: std :: os :: raw :: c_ushort , pub err : __uint64_t , pub trapno : __uint64_t , pub oldmask : __uint64_t , pub cr2 : __uint64_t , pub __bindgen_anon_1 : sigcontext__bindgen_ty_1 , pub __reserved1 : [ __uint64_t ; 8usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigcontext__bindgen_ty_1 { pub fpstate : * mut _fpstate , pub __fpstate_word : __uint64_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_sigcontext__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigcontext__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( sigcontext__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigcontext__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigcontext__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext__bindgen_ty_1 ) ) . fpstate as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext__bindgen_ty_1 ) , "::" , stringify ! ( fpstate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext__bindgen_ty_1 ) ) . __fpstate_word as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext__bindgen_ty_1 ) , "::" , stringify ! ( __fpstate_word ) ) ) ; } # [ test ] fn bindgen_test_layout_sigcontext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigcontext > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( sigcontext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigcontext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigcontext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . r8 as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( r8 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . r9 as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( r9 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . r10 as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( r10 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . r11 as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( r11 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . r12 as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( r12 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . r13 as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( r13 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . r14 as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( r14 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . r15 as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( r15 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . rdi as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rdi ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . rsi as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rsi ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . rbp as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rbp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . rbx as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rbx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . rdx as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rdx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . rax as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . rcx as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rcx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . rsp as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rsp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . rip as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rip ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . eflags as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( eflags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . cs as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( cs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . gs as * const _ as usize } , 146usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( gs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . fs as * const _ as usize } , 148usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( fs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . __pad0 as * const _ as usize } , 150usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( __pad0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . err as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( err ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . trapno as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( trapno ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . oldmask as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( oldmask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . cr2 as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( cr2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigcontext ) ) . __reserved1 as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( __reserved1 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xsave_hdr { pub xstate_bv : __uint64_t , pub __glibc_reserved1 : [ __uint64_t ; 2usize ] , pub __glibc_reserved2 : [ __uint64_t ; 5usize ] , } # [ test ] fn bindgen_test_layout__xsave_hdr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xsave_hdr > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( _xsave_hdr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xsave_hdr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xsave_hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xsave_hdr ) ) . xstate_bv as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xsave_hdr ) , "::" , stringify ! ( xstate_bv ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xsave_hdr ) ) . __glibc_reserved1 as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xsave_hdr ) , "::" , stringify ! ( __glibc_reserved1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xsave_hdr ) ) . __glibc_reserved2 as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xsave_hdr ) , "::" , stringify ! ( __glibc_reserved2 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _ymmh_state { pub ymmh_space : [ __uint32_t ; 64usize ] , } # [ test ] fn bindgen_test_layout__ymmh_state ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _ymmh_state > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( _ymmh_state ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _ymmh_state > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( _ymmh_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _ymmh_state ) ) . ymmh_space as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _ymmh_state ) , "::" , stringify ! ( ymmh_space ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _xstate { pub fpstate : _fpstate , pub xstate_hdr : _xsave_hdr , pub ymmh : _ymmh_state , } # [ test ] fn bindgen_test_layout__xstate ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xstate > ( ) , 832usize , concat ! ( "Size of: " , stringify ! ( _xstate ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xstate > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xstate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xstate ) ) . fpstate as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xstate ) , "::" , stringify ! ( fpstate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xstate ) ) . xstate_hdr as * const _ as usize } , 512usize , concat ! ( "Alignment of field: " , stringify ! ( _xstate ) , "::" , stringify ! ( xstate_hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xstate ) ) . ymmh as * const _ as usize } , 576usize , concat ! ( "Alignment of field: " , stringify ! ( _xstate ) , "::" , stringify ! ( ymmh ) ) ) ; } extern "C" {
 pub fn sigreturn ( __scp : * mut sigcontext , ) -> :: std :: os :: raw :: c_int ; 
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct stack_t { pub ss_sp : * mut :: std :: os :: raw :: c_void , pub ss_flags : :: std :: os :: raw :: c_int , pub ss_size : usize , } # [ test ] fn bindgen_test_layout_stack_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < stack_t > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( stack_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < stack_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( stack_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const stack_t ) ) . ss_sp as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( stack_t ) , "::" , stringify ! ( ss_sp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const stack_t ) ) . ss_flags as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( stack_t ) , "::" , stringify ! ( ss_flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const stack_t ) ) . ss_size as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( stack_t ) , "::" , stringify ! ( ss_size ) ) ) ; } pub type greg_t = :: std :: os :: raw :: c_longlong ; pub type gregset_t = [ greg_t ; 23usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _libc_fpxreg { pub significand : [ :: std :: os :: raw :: c_ushort ; 4usize ] , pub exponent : :: std :: os :: raw :: c_ushort , pub __glibc_reserved1 : [ :: std :: os :: raw :: c_ushort ; 3usize ] , } # [ test ] fn bindgen_test_layout__libc_fpxreg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _libc_fpxreg > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _libc_fpxreg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _libc_fpxreg > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( _libc_fpxreg ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _libc_fpxreg ) ) . significand as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _libc_fpxreg ) , "::" , stringify ! ( significand ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _libc_fpxreg ) ) . exponent as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _libc_fpxreg ) , "::" , stringify ! ( exponent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _libc_fpxreg ) ) . __glibc_reserved1 as * const _ as usize } , 10usize , concat ! ( "Alignment of field: " , stringify ! ( _libc_fpxreg ) , "::" , stringify ! ( __glibc_reserved1 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _libc_xmmreg { pub element : [ __uint32_t ; 4usize ] , } # [ test ] fn bindgen_test_layout__libc_xmmreg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _libc_xmmreg > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _libc_xmmreg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _libc_xmmreg > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( _libc_xmmreg ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _libc_xmmreg ) ) . element as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _libc_xmmreg ) , "::" , stringify ! ( element ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _libc_fpstate { pub cwd : __uint16_t , pub swd : __uint16_t , pub ftw : __uint16_t , pub fop : __uint16_t , pub rip : __uint64_t , pub rdp : __uint64_t , pub mxcsr : __uint32_t , pub mxcr_mask : __uint32_t , pub _st : [ _libc_fpxreg ; 8usize ] , pub _xmm : [ _libc_xmmreg ; 16usize ] , pub __glibc_reserved1 : [ __uint32_t ; 24usize ] , } # [ test ] fn bindgen_test_layout__libc_fpstate ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _libc_fpstate > ( ) , 512usize , concat ! ( "Size of: " , stringify ! ( _libc_fpstate ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _libc_fpstate > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _libc_fpstate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _libc_fpstate ) ) . cwd as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( cwd ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _libc_fpstate ) ) . swd as * const _ as usize } , 2usize , concat ! ( "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( swd ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _libc_fpstate ) ) . ftw as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( ftw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _libc_fpstate ) ) . fop as * const _ as usize } , 6usize , concat ! ( "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( fop ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _libc_fpstate ) ) . rip as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( rip ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _libc_fpstate ) ) . rdp as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( rdp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _libc_fpstate ) ) . mxcsr as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( mxcsr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _libc_fpstate ) ) . mxcr_mask as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( mxcr_mask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _libc_fpstate ) ) . _st as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( _st ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _libc_fpstate ) ) . _xmm as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( _xmm ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _libc_fpstate ) ) . __glibc_reserved1 as * const _ as usize } , 416usize , concat ! ( "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( __glibc_reserved1 ) ) ) ; } pub type fpregset_t = * mut _libc_fpstate ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mcontext_t { pub gregs : gregset_t , pub fpregs : fpregset_t , pub __reserved1 : [ :: std :: os :: raw :: c_ulonglong ; 8usize ] , } # [ test ] fn bindgen_test_layout_mcontext_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mcontext_t > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( mcontext_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mcontext_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( mcontext_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const mcontext_t ) ) . gregs as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( mcontext_t ) , "::" , stringify ! ( gregs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const mcontext_t ) ) . fpregs as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( mcontext_t ) , "::" , stringify ! ( fpregs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const mcontext_t ) ) . __reserved1 as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( mcontext_t ) , "::" , stringify ! ( __reserved1 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ucontext_t { pub uc_flags : :: std :: os :: raw :: c_ulong , pub uc_link : * mut ucontext_t , pub uc_stack : stack_t , pub uc_mcontext : mcontext_t , pub uc_sigmask : sigset_t , pub __fpregs_mem : _libc_fpstate , } # [ test ] fn bindgen_test_layout_ucontext_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ucontext_t > ( ) , 936usize , concat ! ( "Size of: " , stringify ! ( ucontext_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ucontext_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ucontext_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ucontext_t ) ) . uc_flags as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ucontext_t ) , "::" , stringify ! ( uc_flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ucontext_t ) ) . uc_link as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ucontext_t ) , "::" , stringify ! ( uc_link ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ucontext_t ) ) . uc_stack as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( ucontext_t ) , "::" , stringify ! ( uc_stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ucontext_t ) ) . uc_mcontext as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( ucontext_t ) , "::" , stringify ! ( uc_mcontext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ucontext_t ) ) . uc_sigmask as * const _ as usize } , 296usize , concat ! ( "Alignment of field: " , stringify ! ( ucontext_t ) , "::" , stringify ! ( uc_sigmask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ucontext_t ) ) . __fpregs_mem as * const _ as usize } , 424usize , concat ! ( "Alignment of field: " , stringify ! ( ucontext_t ) , "::" , stringify ! ( __fpregs_mem ) ) ) ; } extern "C" {
 pub fn siginterrupt ( __sig : :: std :: os :: raw :: c_int , __interrupt : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} pub const SS_ONSTACK : _bindgen_ty_9 = 1 ; pub const SS_DISABLE : _bindgen_ty_9 = 2 ; pub type _bindgen_ty_9 = :: std :: os :: raw :: c_uint ; extern "C" {
 pub fn sigaltstack ( __ss : * const stack_t , __oss : * mut stack_t , ) -> :: std :: os :: raw :: c_int ; 
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigstack { pub ss_sp : * mut :: std :: os :: raw :: c_void , pub ss_onstack : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_sigstack ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigstack > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sigstack ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigstack > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigstack ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigstack ) ) . ss_sp as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigstack ) , "::" , stringify ! ( ss_sp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigstack ) ) . ss_onstack as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( sigstack ) , "::" , stringify ! ( ss_onstack ) ) ) ; } extern "C" {
 pub fn sigstack ( __ss : * mut sigstack , __oss : * mut sigstack , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn pthread_sigmask ( __how : :: std :: os :: raw :: c_int , __newmask : * const __sigset_t , __oldmask : * mut __sigset_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn pthread_kill ( __threadid : pthread_t , __signo : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn __libc_current_sigrtmin ( ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn __libc_current_sigrtmax ( ) -> :: std :: os :: raw :: c_int ; 
} pub type int_least8_t = :: std :: os :: raw :: c_schar ; pub type int_least16_t = :: std :: os :: raw :: c_short ; pub type int_least32_t = :: std :: os :: raw :: c_int ; pub type int_least64_t = :: std :: os :: raw :: c_long ; pub type uint_least8_t = :: std :: os :: raw :: c_uchar ; pub type uint_least16_t = :: std :: os :: raw :: c_ushort ; pub type uint_least32_t = :: std :: os :: raw :: c_uint ; pub type uint_least64_t = :: std :: os :: raw :: c_ulong ; pub type int_fast8_t = :: std :: os :: raw :: c_schar ; pub type int_fast16_t = :: std :: os :: raw :: c_long ; pub type int_fast32_t = :: std :: os :: raw :: c_long ; pub type int_fast64_t = :: std :: os :: raw :: c_long ; pub type uint_fast8_t = :: std :: os :: raw :: c_uchar ; pub type uint_fast16_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast32_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast64_t = :: std :: os :: raw :: c_ulong ; pub type intmax_t = __intmax_t ; pub type uintmax_t = __uintmax_t ; pub const MODBUS_EXCEPTION_ILLEGAL_FUNCTION : _bindgen_ty_10 = 1 ; pub const MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS : _bindgen_ty_10 = 2 ; pub const MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE : _bindgen_ty_10 = 3 ; pub const MODBUS_EXCEPTION_SLAVE_OR_SERVER_FAILURE : _bindgen_ty_10 = 4 ; pub const MODBUS_EXCEPTION_ACKNOWLEDGE : _bindgen_ty_10 = 5 ; pub const MODBUS_EXCEPTION_SLAVE_OR_SERVER_BUSY : _bindgen_ty_10 = 6 ; pub const MODBUS_EXCEPTION_NEGATIVE_ACKNOWLEDGE : _bindgen_ty_10 = 7 ; pub const MODBUS_EXCEPTION_MEMORY_PARITY : _bindgen_ty_10 = 8 ; pub const MODBUS_EXCEPTION_NOT_DEFINED : _bindgen_ty_10 = 9 ; pub const MODBUS_EXCEPTION_GATEWAY_PATH : _bindgen_ty_10 = 10 ; pub const MODBUS_EXCEPTION_GATEWAY_TARGET : _bindgen_ty_10 = 11 ; pub const MODBUS_EXCEPTION_MAX : _bindgen_ty_10 = 12 ; pub type _bindgen_ty_10 = :: std :: os :: raw :: c_uint ; extern "C" {
 # [ link_name = "\u{1}libmodbus_version_major" ] 
 pub static mut  libmodbus_version_major  :  :: std :: os :: raw :: c_uint ;
} extern "C" {
 # [ link_name = "\u{1}libmodbus_version_minor" ] 
 pub static mut  libmodbus_version_minor  :  :: std :: os :: raw :: c_uint ;
} extern "C" {
 # [ link_name = "\u{1}libmodbus_version_micro" ] 
 pub static mut  libmodbus_version_micro  :  :: std :: os :: raw :: c_uint ;
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _modbus { _unused : [ u8 ; 0 ] } pub type modbus_t = _modbus ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct modbus_mapping_t { pub nb_bits : :: std :: os :: raw :: c_int , pub start_bits : :: std :: os :: raw :: c_int , pub nb_input_bits : :: std :: os :: raw :: c_int , pub start_input_bits : :: std :: os :: raw :: c_int , pub nb_input_registers : :: std :: os :: raw :: c_int , pub start_input_registers : :: std :: os :: raw :: c_int , pub nb_registers : :: std :: os :: raw :: c_int , pub start_registers : :: std :: os :: raw :: c_int , pub tab_bits : * mut u8 , pub tab_input_bits : * mut u8 , pub tab_input_registers : * mut u16 , pub tab_registers : * mut u16 , } # [ test ] fn bindgen_test_layout_modbus_mapping_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < modbus_mapping_t > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( modbus_mapping_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < modbus_mapping_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( modbus_mapping_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const modbus_mapping_t ) ) . nb_bits as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( modbus_mapping_t ) , "::" , stringify ! ( nb_bits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const modbus_mapping_t ) ) . start_bits as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( modbus_mapping_t ) , "::" , stringify ! ( start_bits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const modbus_mapping_t ) ) . nb_input_bits as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( modbus_mapping_t ) , "::" , stringify ! ( nb_input_bits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const modbus_mapping_t ) ) . start_input_bits as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( modbus_mapping_t ) , "::" , stringify ! ( start_input_bits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const modbus_mapping_t ) ) . nb_input_registers as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( modbus_mapping_t ) , "::" , stringify ! ( nb_input_registers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const modbus_mapping_t ) ) . start_input_registers as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( modbus_mapping_t ) , "::" , stringify ! ( start_input_registers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const modbus_mapping_t ) ) . nb_registers as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( modbus_mapping_t ) , "::" , stringify ! ( nb_registers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const modbus_mapping_t ) ) . start_registers as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( modbus_mapping_t ) , "::" , stringify ! ( start_registers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const modbus_mapping_t ) ) . tab_bits as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( modbus_mapping_t ) , "::" , stringify ! ( tab_bits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const modbus_mapping_t ) ) . tab_input_bits as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( modbus_mapping_t ) , "::" , stringify ! ( tab_input_bits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const modbus_mapping_t ) ) . tab_input_registers as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( modbus_mapping_t ) , "::" , stringify ! ( tab_input_registers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const modbus_mapping_t ) ) . tab_registers as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( modbus_mapping_t ) , "::" , stringify ! ( tab_registers ) ) ) ; } pub const modbus_error_recovery_mode_MODBUS_ERROR_RECOVERY_NONE : modbus_error_recovery_mode = modbus_error_recovery_mode ( 0 ) ; pub const modbus_error_recovery_mode_MODBUS_ERROR_RECOVERY_LINK : modbus_error_recovery_mode = modbus_error_recovery_mode ( 2 ) ; pub const modbus_error_recovery_mode_MODBUS_ERROR_RECOVERY_PROTOCOL : modbus_error_recovery_mode = modbus_error_recovery_mode ( 4 ) ; impl :: std :: ops :: BitOr < modbus_error_recovery_mode > for modbus_error_recovery_mode { type Output = Self ; # [ inline ] fn bitor ( self , other : Self ) -> Self { modbus_error_recovery_mode ( self . 0 | other . 0 ) } } impl :: std :: ops :: BitOrAssign for modbus_error_recovery_mode { # [ inline ] fn bitor_assign ( & mut self , rhs : modbus_error_recovery_mode ) { self . 0 |= rhs . 0 ; } } impl :: std :: ops :: BitAnd < modbus_error_recovery_mode > for modbus_error_recovery_mode { type Output = Self ; # [ inline ] fn bitand ( self , other : Self ) -> Self { modbus_error_recovery_mode ( self . 0 & other . 0 ) } } impl :: std :: ops :: BitAndAssign for modbus_error_recovery_mode { # [ inline ] fn bitand_assign ( & mut self , rhs : modbus_error_recovery_mode ) { self . 0 &= rhs . 0 ; } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub struct modbus_error_recovery_mode ( pub :: std :: os :: raw :: c_uint ) ; extern "C" {
 pub fn modbus_set_slave ( ctx : * mut modbus_t , slave : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_get_slave ( ctx : * mut modbus_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_set_error_recovery ( ctx : * mut modbus_t , error_recovery : modbus_error_recovery_mode , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_set_socket ( ctx : * mut modbus_t , s : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_get_socket ( ctx : * mut modbus_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_get_response_timeout ( ctx : * mut modbus_t , to_sec : * mut u32 , to_usec : * mut u32 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_set_response_timeout ( ctx : * mut modbus_t , to_sec : u32 , to_usec : u32 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_get_byte_timeout ( ctx : * mut modbus_t , to_sec : * mut u32 , to_usec : * mut u32 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_set_byte_timeout ( ctx : * mut modbus_t , to_sec : u32 , to_usec : u32 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_get_indication_timeout ( ctx : * mut modbus_t , to_sec : * mut u32 , to_usec : * mut u32 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_set_indication_timeout ( ctx : * mut modbus_t , to_sec : u32 , to_usec : u32 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_get_header_length ( ctx : * mut modbus_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_connect ( ctx : * mut modbus_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_close ( ctx : * mut modbus_t , ) ; 
} extern "C" {
 pub fn modbus_free ( ctx : * mut modbus_t , ) ; 
} extern "C" {
 pub fn modbus_flush ( ctx : * mut modbus_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_set_debug ( ctx : * mut modbus_t , flag : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_strerror ( errnum : :: std :: os :: raw :: c_int , ) -> * const :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn modbus_read_bits ( ctx : * mut modbus_t , addr : :: std :: os :: raw :: c_int , nb : :: std :: os :: raw :: c_int , dest : * mut u8 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_read_input_bits ( ctx : * mut modbus_t , addr : :: std :: os :: raw :: c_int , nb : :: std :: os :: raw :: c_int , dest : * mut u8 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_read_registers ( ctx : * mut modbus_t , addr : :: std :: os :: raw :: c_int , nb : :: std :: os :: raw :: c_int , dest : * mut u16 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_read_input_registers ( ctx : * mut modbus_t , addr : :: std :: os :: raw :: c_int , nb : :: std :: os :: raw :: c_int , dest : * mut u16 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_write_bit ( ctx : * mut modbus_t , coil_addr : :: std :: os :: raw :: c_int , status : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_write_register ( ctx : * mut modbus_t , reg_addr : :: std :: os :: raw :: c_int , value : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_write_bits ( ctx : * mut modbus_t , addr : :: std :: os :: raw :: c_int , nb : :: std :: os :: raw :: c_int , data : * const u8 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_write_registers ( ctx : * mut modbus_t , addr : :: std :: os :: raw :: c_int , nb : :: std :: os :: raw :: c_int , data : * const u16 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_mask_write_register ( ctx : * mut modbus_t , addr : :: std :: os :: raw :: c_int , and_mask : u16 , or_mask : u16 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_write_and_read_registers ( ctx : * mut modbus_t , write_addr : :: std :: os :: raw :: c_int , write_nb : :: std :: os :: raw :: c_int , src : * const u16 , read_addr : :: std :: os :: raw :: c_int , read_nb : :: std :: os :: raw :: c_int , dest : * mut u16 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_report_slave_id ( ctx : * mut modbus_t , max_dest : :: std :: os :: raw :: c_int , dest : * mut u8 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_mapping_new_start_address ( start_bits : :: std :: os :: raw :: c_uint , nb_bits : :: std :: os :: raw :: c_uint , start_input_bits : :: std :: os :: raw :: c_uint , nb_input_bits : :: std :: os :: raw :: c_uint , start_registers : :: std :: os :: raw :: c_uint , nb_registers : :: std :: os :: raw :: c_uint , start_input_registers : :: std :: os :: raw :: c_uint , nb_input_registers : :: std :: os :: raw :: c_uint , ) -> * mut modbus_mapping_t ; 
} extern "C" {
 pub fn modbus_mapping_new ( nb_bits : :: std :: os :: raw :: c_int , nb_input_bits : :: std :: os :: raw :: c_int , nb_registers : :: std :: os :: raw :: c_int , nb_input_registers : :: std :: os :: raw :: c_int , ) -> * mut modbus_mapping_t ; 
} extern "C" {
 pub fn modbus_mapping_free ( mb_mapping : * mut modbus_mapping_t , ) ; 
} extern "C" {
 pub fn modbus_send_raw_request ( ctx : * mut modbus_t , raw_req : * mut u8 , raw_req_length : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_receive ( ctx : * mut modbus_t , req : * mut u8 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_receive_confirmation ( ctx : * mut modbus_t , rsp : * mut u8 , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_reply ( ctx : * mut modbus_t , req : * const u8 , req_length : :: std :: os :: raw :: c_int , mb_mapping : * mut modbus_mapping_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_reply_exception ( ctx : * mut modbus_t , req : * const u8 , exception_code : :: std :: os :: raw :: c_uint , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_set_bits_from_byte ( dest : * mut u8 , idx : :: std :: os :: raw :: c_int , value : u8 , ) ; 
} extern "C" {
 pub fn modbus_set_bits_from_bytes ( dest : * mut u8 , idx : :: std :: os :: raw :: c_int , nb_bits : :: std :: os :: raw :: c_uint , tab_byte : * const u8 , ) ; 
} extern "C" {
 pub fn modbus_get_byte_from_bits ( src : * const u8 , idx : :: std :: os :: raw :: c_int , nb_bits : :: std :: os :: raw :: c_uint , ) -> u8 ; 
} extern "C" {
 pub fn modbus_get_float ( src : * const u16 , ) -> f32 ; 
} extern "C" {
 pub fn modbus_get_float_abcd ( src : * const u16 , ) -> f32 ; 
} extern "C" {
 pub fn modbus_get_float_dcba ( src : * const u16 , ) -> f32 ; 
} extern "C" {
 pub fn modbus_get_float_badc ( src : * const u16 , ) -> f32 ; 
} extern "C" {
 pub fn modbus_get_float_cdab ( src : * const u16 , ) -> f32 ; 
} extern "C" {
 pub fn modbus_set_float ( f : f32 , dest : * mut u16 , ) ; 
} extern "C" {
 pub fn modbus_set_float_abcd ( f : f32 , dest : * mut u16 , ) ; 
} extern "C" {
 pub fn modbus_set_float_dcba ( f : f32 , dest : * mut u16 , ) ; 
} extern "C" {
 pub fn modbus_set_float_badc ( f : f32 , dest : * mut u16 , ) ; 
} extern "C" {
 pub fn modbus_set_float_cdab ( f : f32 , dest : * mut u16 , ) ; 
} extern "C" {
 pub fn modbus_new_tcp ( ip_address : * const :: std :: os :: raw :: c_char , port : :: std :: os :: raw :: c_int , ) -> * mut modbus_t ; 
} extern "C" {
 pub fn modbus_tcp_listen ( ctx : * mut modbus_t , nb_connection : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_tcp_accept ( ctx : * mut modbus_t , s : * mut :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_new_tcp_pi ( node : * const :: std :: os :: raw :: c_char , service : * const :: std :: os :: raw :: c_char , ) -> * mut modbus_t ; 
} extern "C" {
 pub fn modbus_tcp_pi_listen ( ctx : * mut modbus_t , nb_connection : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_tcp_pi_accept ( ctx : * mut modbus_t , s : * mut :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_new_rtu ( device : * const :: std :: os :: raw :: c_char , baud : :: std :: os :: raw :: c_int , parity : :: std :: os :: raw :: c_char , data_bit : :: std :: os :: raw :: c_int , stop_bit : :: std :: os :: raw :: c_int , ) -> * mut modbus_t ; 
} extern "C" {
 pub fn modbus_rtu_set_serial_mode ( ctx : * mut modbus_t , mode : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_rtu_get_serial_mode ( ctx : * mut modbus_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_rtu_set_rts ( ctx : * mut modbus_t , mode : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_rtu_get_rts ( ctx : * mut modbus_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_rtu_set_custom_rts ( ctx : * mut modbus_t , set_rts : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut modbus_t , on : :: std :: os :: raw :: c_int ) > , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_rtu_set_rts_delay ( ctx : * mut modbus_t , us : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn modbus_rtu_get_rts_delay ( ctx : * mut modbus_t , ) -> :: std :: os :: raw :: c_int ; 
}